# -*- coding: utf-8 -*-
"""Ejercicios_27Ene22_equipo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-YjOr2gtK_1LxmcS1E4F7voD0vcA1TSu

# Ejercicios bases de Python

## Estructuras, asignación y funciones

### 1. Creando una agenda 

Utiliza los conceptos básicos de python para crear una agenda telefónica. Deberás completar las funciones crear_agenda, agregar_contacto, eliminimar_contacto y buscar_contacto que se encuentran en las siguientes celdas.

* ```crear_agenda()```, esta función devuelve una nueva agenda vacía, elige el tipo de dato que creas adecuado para este proposito.
* ```agregar_contacto(agenda, nombre, numero)```, esta función debe permitir agregar un nuevo contacto a la agenda, además si un contacto ya existe con el nombre recibido entonces debes almacenar su nuevo numero sin eliminar el anterior.
* ```buscar_contacto(agenda, nombre)```, esta función debe de regresar el o los números registados de un contacto, si el contacto no existe entonces imprimer el mensaje "Contacto no encontrado en la agenda".
* ```eliminar_contacto(agenda, nombre)```, esta función permite eliminar a un contacto de la agenda, si el contacto no existe entonces imprimer el mensaje "Contacto no encontrado en la agenda".
"""

def crear_agenda():
    agenda = {}
    return agenda

def agregar_contacto(agenda, nombre, numero):
    """
    Tip:
    Primero debes comprobar si existe el contacto
    si no existe entonces crea uno nuevo y guarda
    su nombre y numero"""
    if nombre not in agenda.keys():
      
      numeros=[numero]
      agenda[nombre]=numeros
    else:
      print("Este nombre ya existe, se agrega nuevo numero en la agenda")
      numeros=agenda.get(nombre)
      numeros.append(numero)

    return agenda

agenda = crear_agenda()
agenda = agregar_contacto(agenda, "Javier", "1234567890")
agenda

def buscar_contacto(agenda, nombre):
    """
    Busca el contacto en la agenda, imprime su nombre y numero
    Si tiene mas de un numero, imprime todos
    Si el contacto no existe, imprime "Contacto no encontrado en la agenda"
    """
    if nombre in agenda.keys():
      print("Nombre: "+ nombre+" Numero(s): ", agenda.get(nombre))
    else:
      print("Este nombre no existe en la agenda")
    return

buscar_contacto(agenda, "Javier")
agenda = agregar_contacto(agenda, "Javier", "0987654321")
buscar_contacto(agenda, "Javier")

def eliminar_contacto(agenda, nombre):
    """
    Elimina el contacto de la agenda
    si el contacto no existe imprime "Contacto no encontrado en la agenda"
    """
    if nombre in agenda.keys():
      print("Se eliminó: "+ nombre+" Con numero(s): ", agenda.get(nombre))
      agenda.pop(nombre)
      
    else:
      print("Este nombre no existe en la agenda")
    return agenda

agenda = eliminar_contacto(agenda,"Javier")

agenda

"""# Ejercicios estadística

### Función suma

$$
    suma(a) = \sum_{i=1}^{n}a_i
$$
"""

def suma(x):
    suma = 0
    for i in x:
      suma=suma+i
    return suma

suma([1, 2, 3, 4, 5])

assert suma([1, 2, 3, 4, 5]) == 15

"""### Función promedio.

$$
	\bar{x} = \dfrac{\sum_{i=1}^{n}x_i}{n}
$$
"""

def promedio(x):
    promedio = 0
    for i in x:
      promedio=promedio+i
    promedio=promedio/len(x)
    return promedio

"""promedio"""

assert promedio([1, 2, 3, 4, 5]) == 3, "Error en promedio"

"""### Función varianza.
$$
\sigma^2 = \frac{1}{n} \sum_{i=1}^{n}(x_i - \bar{x})^2
$$
"""

def var(x):
    var = 0
    p=promedio(x)
    for i in x:
      var=var+((i-p)*(i-p))
    var=var/len(x)
    return var

assert var([1, 2, 3, 4, 5]) == 2, "Error en var"

"""# Ejercicios álgebra lineal

## Vectores con listas

### Ones

Completa la función ones1D que recibe como parámetros un entero $n$ y retorna una lista de tamaño $n$ con todos sus elementos con el valor $1$.

Ejemplo:

```
>>> ones(5)
[1, 1, 1, 1, 1]
```
"""

def ones_1d(n):
    ones_list = []
    for i in range(n):
      ones_list.append(1)
    return ones_list

"""Ejecuta la siguiente celda para comprobar la función ones1D:"""

assert len(ones_1d(10)) == 10 and  ones_1d(3).count(1) == 3 and sum(ones_1d(5)) == 5  , "error en la funcion ones_1d"
print("La funcion es correcta")

"""### Ones 2D

Completa la función ones_2d que recibe como parámetros un entero $n$ y un entero $m$ y retorna una lista con $n$ sub-listas cada una de tamaño $m$ con todos sus elementos con el valor 1. En otras palabras, una matriz $n \times m$ con sus elementos iniciados con valor $1$.

Ejemplo:



```
>>> ones_2d(2, 3)
[[1, 1, 1], [1, 1, 1]]
```
"""

def ones_2d(m, n):
    ones_ll = []
    for i in range(m) :
      ones_ll.append(ones_1d(n))
    return ones_ll

"""Ejecuta la siguiente celda para comprobar la función ones2D:"""

assert len(ones_2d(2, 3)) == 2 and len(ones_2d(2, 3)[0]) == 3 and sum([x_i for sl in ones_2d(3, 2) for x_i in sl]) == 6 , "error en la funcion ones_2d"
print("La funcion es correcta")

"""### Producto punto (inner)

Completa la función ones_2d que recibe como parametros dos listas a, b de la misma longitúd y retorna el producto punto de ambos.

El producto punto está definido como:

$$a = [a_1 a_2 ... a_n] \: y \: b = [b_1 b_2 ... b_n]$$

$$
a \cdot b = a_1*b_1 + a_2*b_2 + \dots + a_n*b_n
$$
"""

def inner(a, b):
    suma=0
    if len(a)==len(b):
      for i in range(len(a)):
        suma=suma+a[i]*b[i]
    else:
        print("Las dimensiones de a y b no corresponden")
    return suma

a=[1, 2, 3]
b= [1, 2 ,3]
a[1]*b[1]

assert inner([1, 2, 3], [1, 2 ,3]) == 14, "Error en inner"
print("Correcto")

"""## Matrices con listas de listas

### Matriz identidad
$$
	I_{ij} = \begin{cases}
		1 & i=j\\
		0 & i \neq j\\
	\end{cases}
$$
"""

def eye(n):
    '''
    Esta funcion debe regresar la matriz identidad de tamano nxn
    '''
    I = []
    for i in range(n):
      R = []
      for j in range(n):
        if i==j:
          R.append(1)
        else:
          R.append(0)
      I.append(R)  
    return I

assert eye(2) == [[1, 0], [0, 1]], "Error en eye"

"""### Matriz transpuesta

$$C = A^T \Leftrightarrow c_{ij} = a{ji}$$

Por ejemplo, si:
	$$
	A = \begin{bmatrix}
	a_{11} & a_{12}  \\
	a_{21} & a_{22}  \\
	a_{31} & a_{32}  \\
	\end{bmatrix}
	$$
	entonces
	$$
	A^T = \begin{bmatrix}
	a_{11} & a_{21} & a_{31} \\
	a_{12} & a_{22} & a_{32} \\
	\end{bmatrix}
	$$
"""

def traspose(A):
    '''
    Esta funcion debe regresar la transpuesta de A
    '''
    A_t = []
    for j in range(len(A[0])):
      R=[]
      for i in range(len(A)):
        R.append(A[i][j])
      A_t.append(R)
    return A_t

A=[[1, 2], [3, 4], [5, 6]]
traspose(A)

assert traspose([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]], "Error en traspose"

"""### Valida multiplicación

```True``` si
$$A \qquad es \qquad mxn$$
y
$$B \qquad es \qquad nxp$$
```False``` en otro caso
"""

def validate_mat_mul(A, B):
    val = False
    val=len(A[0])==len(B)
    return val

assert validate_mat_mul([[1, 2], [3, 4]], [[5, 6], [7, 8]]) and \
validate_mat_mul([[1, 2], [3, 4], [5, 6]], [[1, 2, 3], [4, 5, 6]]) and \
not validate_mat_mul([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2], [3, 4]]), "Error en validate_mat_mul"

"""### Multiplicación de matrices

Si $A \in \mathbb{R}^{m \times n}$ y $B \in \mathbb{R}^{n \times p}$ entonces:
$$
C = A B \in \mathbb{R}^{m \times p}\Leftrightarrow c_{ij} = \sum_{k=1}^{n}a_{ik} b_{kj}
$$
"""

def mat_mul(A, B):
  C =[]
  if validate_mat_mul(A,B)==True:
    B_t=traspose(B)
     
    for i in A:
      R=[]
      for j in B_t: 
        R.append(inner(i,j))
      C.append(R)
  return C

assert mat_mul([[1, 2], [3, 4], [5, 6]], [[2, 2], [2, 2]]) == [[6, 6], [14, 14], [22, 22]], "Error en mat_mul"